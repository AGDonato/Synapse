/**
 * AGENDADOR DE BACKUP AUTOM√ÅTICO - GERENCIAMENTO DE CRONOGRAMAS
 *
 * Este arquivo implementa sistema de agendamento para backups autom√°ticos.
 * Funcionalidades:
 * - Agendamento baseado em express√µes CRON
 * - M√∫ltiplas tarefas de backup com configura√ß√µes independentes
 * - Controle de concorr√™ncia para evitar sobrecarga
 * - Sistema de retry com atraso configur√°vel
 * - Monitoramento de sa√∫de dos agendamentos
 * - Hist√≥rico de execu√ß√µes e falhas
 * - Timezone configurvel para execu√ß√£o correta
 *
 * Caracter√≠sticas:
 * - Singleton pattern para garantir √∫nica inst√¢ncia
 * - Health checks peri√≥dicos dos agendamentos
 * - Integra√ß√£o com sistema de error tracking
 * - Controle granular de ativa√ß√£o/desativa√ß√£o
 * - Persist√™ncia de configura√ß√µes via localStorage
 *
 * Uso t√≠pico:
 * - Daily backup: '0 2 * * *' (todo dia √†s 2h)
 * - Weekly backup: '0 1 * * 0' (domingo √†1h)
 * - Hourly backup: '0 * * * *' (a cada hora)
 */

import { env } from '../../config/env';
import { type BackupOptions, type BackupScope, backupManager } from './backupManager';
import { getErrorTrackingUtils } from '../monitoring/errorTracking';
import { logger } from '../../utils/logger';

/**
 * Interface para defini√ß√£o de agendamento de backup
 */
export interface BackupSchedule {
  /** Identificador √∫nico do agendamento */
  id: string;
  /** Nome descritivo do agendamento */
  name: string;
  /** Se o agendamento est√° ativo */
  enabled: boolean;
  /** Express√£o CRON para o agendamento */
  cron: string;
  /** Op√ß√µes de backup a serem aplicadas */
  options: BackupOptions;
  /** Timestamp da √∫ltima execu√ß√£o */
  lastRun?: string;
  /** Timestamp da pr√≥xima execu√ß√£o prevista */
  nextRun?: string;
  /** N√∫mero total de execu√ß√µes */
  runCount: number;
  /** N√∫mero de falhas registradas */
  failureCount: number;
  /** M√°ximo de tentativas em caso de falha */
  maxRetries: number;
}

/**
 * Configura√ß√£o do agendador de backups
 */
export interface SchedulerConfig {
  /** Se o agendador est√° globalmente ativo */
  enabled: boolean;
  /** Timezone para c√°lculo dos agendamentos */
  timezone: string;
  /** M√°ximo de backups executando simultaneamente */
  maxConcurrentBackups: number;
  /** Atraso entre tentativas em caso de falha (ms) */
  retryDelay: number;
  /** Intervalo de verifica√ß√£o de sa√∫de (ms) */
  healthCheckInterval: number;
}

/**
 * Classe principal do agendador de backups
 * Implementa singleton pattern para controle centralizado
 */
export class BackupScheduler {
  /** Inst√¢ncia singleton */
  private static instance: BackupScheduler;
  /** Mapa de agendamentos configurados */
  private schedules = new Map<string, BackupSchedule>();
  /** Timers ativos para cada agendamento */
  private activeTimers = new Map<string, number>();
  /** Flag indicando se o agendador est√° ativo */
  private isRunning = false;
  /** Configura√ß√£o atual do agendador */
  private config: SchedulerConfig;
  /** Timer para health checks peri√≥dicos */
  private healthCheckTimer?: number;
  /** Utilit√°rios de rastreamento de erros */
  private errorTracking = getErrorTrackingUtils();

  private constructor() {
    this.config = {
      enabled: env.IS_PRODUCTION || env.IS_STAGING,
      timezone: env.TIMEZONE_DEFAULT || 'America/Sao_Paulo',
      maxConcurrentBackups: env.IS_PRODUCTION ? 2 : 1,
      retryDelay: 30000, // 30 segundos
      healthCheckInterval: 60000, // 1 minuto
    };

    this.initializeDefaultSchedules();
  }

  static getInstance(): BackupScheduler {
    if (!BackupScheduler.instance) {
      BackupScheduler.instance = new BackupScheduler();
    }
    return BackupScheduler.instance;
  }

  /**
   * Inicializar schedules padr√£o baseados no ambiente
   */
  private initializeDefaultSchedules(): void {
    if (env.IS_PRODUCTION) {
      // Backup completo di√°rio √†s 2h
      this.addSchedule({
        id: 'daily-full',
        name: 'Backup Completo Di√°rio',
        enabled: true,
        cron: '0 2 * * *',
        options: {
          type: 'scheduled',
          scope: 'all',
          compress: true,
          encrypt: true,
          maxRetentionDays: 30,
        },
        runCount: 0,
        failureCount: 0,
        maxRetries: 3,
      });

      // Backup de dados do usu√°rio a cada 4 horas
      this.addSchedule({
        id: 'hourly-userdata',
        name: 'Backup de Dados de Usu√°rio',
        enabled: true,
        cron: '0 */4 * * *',
        options: {
          type: 'scheduled',
          scope: 'user-data',
          compress: true,
          encrypt: false,
          maxRetentionDays: 7,
        },
        runCount: 0,
        failureCount: 0,
        maxRetries: 2,
      });
    } else if (env.IS_STAGING) {
      // Backup di√°rio √†s 3h em staging
      this.addSchedule({
        id: 'staging-daily',
        name: 'Backup Di√°rio Staging',
        enabled: true,
        cron: '0 3 * * *',
        options: {
          type: 'scheduled',
          scope: 'all',
          compress: true,
          encrypt: false,
          maxRetentionDays: 14,
        },
        runCount: 0,
        failureCount: 0,
        maxRetries: 2,
      });
    } else if (env.IS_DEVELOPMENT) {
      // Backup de desenvolvimento menos frequente
      this.addSchedule({
        id: 'dev-backup',
        name: 'Backup de Desenvolvimento',
        enabled: false, // Desabilitado por padr√£o
        cron: '0 12 * * 0', // Domingo ao meio-dia
        options: {
          type: 'scheduled',
          scope: 'user-data',
          compress: false,
          encrypt: false,
          maxRetentionDays: 3,
        },
        runCount: 0,
        failureCount: 0,
        maxRetries: 1,
      });
    }
  }

  /**
   * Iniciar o scheduler
   */
  async start(): Promise<void> {
    if (this.isRunning) {
      logger.warn('Scheduler j√° est√° executando');
      return;
    }

    if (!this.config.enabled) {
      logger.info('Scheduler de backup est√° desabilitado');
      return;
    }

    this.isRunning = true;

    try {
      // Carregar schedules salvos
      await this.loadSchedules();

      // Iniciar timers para cada schedule
      for (const schedule of this.schedules.values()) {
        if (schedule.enabled) {
          this.scheduleNext(schedule);
        }
      }

      // Iniciar health check
      this.startHealthCheck();

      logger.info(`üïê Backup scheduler iniciado com ${this.schedules.size} agendamentos`);
    } catch (error) {
      this.isRunning = false;
      this.errorTracking.captureError({
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
        type: 'javascript',
        severity: 'high',
        context: { module: 'BackupScheduler.start' },
      });
      throw error;
    }
  }

  /**
   * Parar o scheduler
   */
  stop(): void {
    if (!this.isRunning) {
      return;
    }

    this.isRunning = false;

    // Limpar todos os timers
    for (const timerId of this.activeTimers.values()) {
      clearTimeout(timerId);
    }
    this.activeTimers.clear();

    // Parar health check
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
      this.healthCheckTimer = undefined;
    }

    logger.info('üõë Backup scheduler parado');
  }

  /**
   * Adicionar novo schedule
   */
  addSchedule(schedule: BackupSchedule): void {
    // Validar cron expression
    if (!this.isValidCron(schedule.cron)) {
      throw new Error(`Express√£o cron inv√°lida: ${schedule.cron}`);
    }

    // Calcular pr√≥xima execu√ß√£o
    schedule.nextRun = this.getNextRunTime(schedule.cron);

    this.schedules.set(schedule.id, schedule);

    // Se scheduler est√° rodando, agendar imediatamente
    if (this.isRunning && schedule.enabled) {
      this.scheduleNext(schedule);
    }

    this.saveSchedules();
    logger.info(`üìÖ Schedule '${schedule.name}' adicionado`);
  }

  /**
   * Remover schedule
   */
  removeSchedule(scheduleId: string): boolean {
    const schedule = this.schedules.get(scheduleId);
    if (!schedule) {
      return false;
    }

    // Limpar timer ativo
    const timerId = this.activeTimers.get(scheduleId);
    if (timerId) {
      clearTimeout(timerId);
      this.activeTimers.delete(scheduleId);
    }

    this.schedules.delete(scheduleId);
    this.saveSchedules();

    logger.info(`üóëÔ∏è Schedule '${schedule.name}' removido`);
    return true;
  }

  /**
   * Habilitar/desabilitar schedule
   */
  toggleSchedule(scheduleId: string, enabled: boolean): boolean {
    const schedule = this.schedules.get(scheduleId);
    if (!schedule) {
      return false;
    }

    schedule.enabled = enabled;

    if (this.isRunning) {
      if (enabled) {
        this.scheduleNext(schedule);
      } else {
        const timerId = this.activeTimers.get(scheduleId);
        if (timerId) {
          clearTimeout(timerId);
          this.activeTimers.delete(scheduleId);
        }
      }
    }

    this.saveSchedules();
    logger.info(
      `${enabled ? '‚úÖ' : '‚ùå'} Schedule '${schedule.name}' ${enabled ? 'habilitado' : 'desabilitado'}`
    );
    return true;
  }

  /**
   * Executar schedule manualmente
   */
  async runScheduleNow(scheduleId: string): Promise<string> {
    const schedule = this.schedules.get(scheduleId);
    if (!schedule) {
      throw new Error(`Schedule ${scheduleId} n√£o encontrado`);
    }

    return await this.executeBackup(schedule);
  }

  /**
   * Obter todos os schedules
   */
  getSchedules(): BackupSchedule[] {
    return Array.from(this.schedules.values());
  }

  /**
   * Obter estat√≠sticas do scheduler
   */
  getStats(): {
    totalSchedules: number;
    enabledSchedules: number;
    activeTimers: number;
    totalRuns: number;
    totalFailures: number;
    isRunning: boolean;
  } {
    const schedules = Array.from(this.schedules.values());

    return {
      totalSchedules: schedules.length,
      enabledSchedules: schedules.filter(s => s.enabled).length,
      activeTimers: this.activeTimers.size,
      totalRuns: schedules.reduce((sum, s) => sum + s.runCount, 0),
      totalFailures: schedules.reduce((sum, s) => sum + s.failureCount, 0),
      isRunning: this.isRunning,
    };
  }

  /**
   * Agendar pr√≥xima execu√ß√£o de um schedule
   */
  private scheduleNext(schedule: BackupSchedule): void {
    // Limpar timer anterior se existir
    const existingTimer = this.activeTimers.get(schedule.id);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }

    const nextRun = this.getNextRunTime(schedule.cron);
    const delay = new Date(nextRun).getTime() - Date.now();

    if (delay > 0) {
      const timerId = window.setTimeout(async () => {
        await this.executeBackup(schedule);

        // Reagendar para pr√≥xima execu√ß√£o se ainda habilitado
        if (schedule.enabled && this.isRunning) {
          this.scheduleNext(schedule);
        }
      }, delay);

      this.activeTimers.set(schedule.id, timerId);
      schedule.nextRun = nextRun;

      logger.info(`‚è∞ Schedule '${schedule.name}' agendado para ${nextRun}`);
    }
  }

  /**
   * Executar backup de um schedule
   */
  private async executeBackup(schedule: BackupSchedule): Promise<string> {
    const startTime = Date.now();

    try {
      logger.info(`üîÑ Executando backup: ${schedule.name}`);

      // Verificar limite de backups concorrentes
      const activeBackups = Array.from(this.activeTimers.values()).length;
      if (activeBackups >= this.config.maxConcurrentBackups) {
        throw new Error('Limite de backups concorrentes atingido');
      }

      // Executar backup
      const backupId = await backupManager.createBackup(schedule.options);

      // Atualizar estat√≠sticas
      schedule.runCount++;
      schedule.lastRun = new Date().toISOString();
      schedule.failureCount = 0; // Reset failure count on success

      const duration = Date.now() - startTime;
      logger.info(`‚úÖ Backup '${schedule.name}' conclu√≠do em ${duration}ms: ${backupId}`);

      this.saveSchedules();
      return backupId;
    } catch (error) {
      schedule.failureCount++;
      schedule.lastRun = new Date().toISOString();

      this.errorTracking.captureError({
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
        type: 'javascript',
        severity: 'high',
        context: {
          module: 'BackupScheduler.executeBackup',
          scheduleId: schedule.id,
          scheduleName: schedule.name,
        },
      });

      logger.error(`‚ùå Falha no backup '${schedule.name}':`, error);

      // Reagendar com delay se n√£o excedeu limite de retry
      if (schedule.failureCount < schedule.maxRetries) {
        setTimeout(() => {
          if (schedule.enabled && this.isRunning) {
            this.executeBackup(schedule);
          }
        }, this.config.retryDelay * schedule.failureCount); // Exponential backoff
      }

      this.saveSchedules();
      throw error;
    }
  }

  /**
   * Health check do scheduler
   */
  private startHealthCheck(): void {
    this.healthCheckTimer = window.setInterval(() => {
      const now = Date.now();
      let issuesFound = 0;

      for (const [scheduleId, schedule] of this.schedules.entries()) {
        if (!schedule.enabled) {
          continue;
        }

        // Verificar se timer ainda existe
        const hasTimer = this.activeTimers.has(scheduleId);
        const nextRun = schedule.nextRun ? new Date(schedule.nextRun).getTime() : 0;
        const isOverdue = nextRun > 0 && now > nextRun + 60000; // 1 minuto de toler√¢ncia

        if (!hasTimer && !isOverdue) {
          logger.warn(`‚ö†Ô∏è Schedule '${schedule.name}' sem timer ativo - reagendando`);
          this.scheduleNext(schedule);
          issuesFound++;
        } else if (isOverdue) {
          logger.error(`üö® Schedule '${schedule.name}' est√° atrasado - executando agora`);
          this.executeBackup(schedule).catch(error =>
            logger.error('Erro executando backup atrasado:', error)
          );
          issuesFound++;
        }
      }

      if (issuesFound === 0 && env.IS_DEVELOPMENT) {
        logger.info(`üíö Health check: ${this.schedules.size} schedules OK`);
      }
    }, this.config.healthCheckInterval);
  }

  /**
   * Calcular pr√≥ximo hor√°rio de execu√ß√£o baseado no cron
   */
  private getNextRunTime(cronExpression: string): string {
    // Implementa√ß√£o simplificada de cron
    // Em produ√ß√£o, usar biblioteca como node-cron ou cron-parser

    const now = new Date();
    const parts = cronExpression.split(' ');

    if (parts.length !== 5) {
      throw new Error('Express√£o cron deve ter 5 campos');
    }

    // Para esta implementa√ß√£o, suportar apenas alguns casos comuns
    const [minute, hour, dayOfMonth, month, dayOfWeek] = parts;

    const nextRun = new Date(now);
    nextRun.setSeconds(0);
    nextRun.setMilliseconds(0);

    // Casos simples
    if (minute !== '*') {
      nextRun.setMinutes(parseInt(minute));
    }

    if (hour !== '*') {
      nextRun.setHours(parseInt(hour));
    }

    // Se hor√°rio j√° passou hoje, mover para amanh√£
    if (nextRun <= now) {
      nextRun.setDate(nextRun.getDate() + 1);
    }

    return nextRun.toISOString();
  }

  /**
   * Validar express√£o cron (simplificado)
   */
  private isValidCron(cronExpression: string): boolean {
    const parts = cronExpression.split(' ');
    if (parts.length !== 5) {
      return false;
    }

    // Valida√ß√£o b√°sica - em produ√ß√£o usar parser mais robusto
    for (const part of parts) {
      if (!/^(\*|\d+|\d+-\d+|\*\/\d+)$/.test(part)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Carregar schedules salvos
   */
  private async loadSchedules(): Promise<void> {
    try {
      const savedSchedules = localStorage.getItem('backup_schedules');
      if (savedSchedules) {
        const schedules: BackupSchedule[] = JSON.parse(savedSchedules);
        for (const schedule of schedules) {
          this.schedules.set(schedule.id, schedule);
        }
        logger.info(`üì• Carregados ${schedules.length} schedules salvos`);
      }
    } catch (error) {
      logger.error('Erro ao carregar schedules:', error);
    }
  }

  /**
   * Salvar schedules
   */
  private saveSchedules(): void {
    try {
      const schedules = Array.from(this.schedules.values());
      localStorage.setItem('backup_schedules', JSON.stringify(schedules));
    } catch (error) {
      logger.error('Erro ao salvar schedules:', error);
    }
  }
}

export const backupScheduler = BackupScheduler.getInstance();
